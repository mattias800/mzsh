#!/usr/bin/env bash
set -euo pipefail

# mzsh-private: manage ~/.privaterc file syncing with 1Password
# This allows users to keep a single private shell config file synced across machines

PRIVATE_FILE="$HOME/.privaterc"
PRIVATE_ITEM="mzsh-private (do not edit)"
PROVIDER="${1:-op}"

usage() {
  cat >&2 << 'EOF'
Usage: mzsh private <subcommand> [options]

Subcommands:
  pull [--provider PROVIDER]  Fetch ~/.privaterc from 1Password (create if missing)
  push [--provider PROVIDER]  Push ~/.privaterc to 1Password

Providers:
  op        1Password CLI (default)

Examples:
  mzsh private pull
  mzsh private push

The ~/.privaterc file is automatically sourced when your shell starts.
EOF
}

require() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

pull() {
  local provider="$1"
  
  case "$provider" in
    op)
      require op
      
      # Try to fetch existing item
      if op item list --format=json 2>/dev/null | jq -e --arg name "$PRIVATE_ITEM" '.[] | select(.title == $name)' >/dev/null 2>&1; then
        # Get the item and extract the note
        op item get "$PRIVATE_ITEM" --format=json 2>/dev/null | jq -r '.notes // ""' > "$PRIVATE_FILE"
        echo "[mzsh] Pulled ~/.privaterc from 1Password" >&2
      else
        # Create new empty file
        cat > "$PRIVATE_FILE" << 'TEMPLATE'
# ~/.privaterc - Private shell configuration
# This file is synced with 1Password across your machines
# Edit this file and run: mzsh private push

# Add your private environment variables, aliases, and functions here
# Example:
# export PRIVATE_TOKEN="your-secret-token"
# alias myalias="command"

TEMPLATE
        echo "[mzsh] Created new ~/.privaterc (not yet in 1Password)" >&2
        echo "[mzsh] Edit it and run: mzsh private push" >&2
      fi
      chmod 600 "$PRIVATE_FILE"
      ;;
    *)
      echo "Unknown provider: $provider" >&2
      return 1
      ;;
  esac
}

push() {
  local provider="$1"
  
  if [[ ! -f "$PRIVATE_FILE" ]]; then
    echo "File not found: $PRIVATE_FILE" >&2
    echo "Run 'mzsh private pull' first to create it" >&2
    return 1
  fi
  
  case "$provider" in
    op)
      require op
      
      local content
      content=$(cat "$PRIVATE_FILE")
      
      # Check if item exists
      if op item list --format=json 2>/dev/null | jq -e --arg name "$PRIVATE_ITEM" '.[] | select(.title == $name)' >/dev/null 2>&1; then
        # Update existing item
        # We need to use a temporary file because op item edit doesn't support stdin for notes
        local tmp_file
        tmp_file=$(mktemp)
        cat "$PRIVATE_FILE" > "$tmp_file"
        op item edit "$PRIVATE_ITEM" --notes "$(cat "$tmp_file")" 2>/dev/null || true
        rm -f "$tmp_file"
        echo "[mzsh] Updated ~/.privaterc in 1Password" >&2
      else
        # Create new item with the file content as notes
        op item create --category secure_note --title "$PRIVATE_ITEM" --notes "$(cat "$PRIVATE_FILE")" 2>/dev/null || true
        echo "[mzsh] Created ~/.privaterc in 1Password" >&2
      fi
      ;;
    *)
      echo "Unknown provider: $provider" >&2
      return 1
      ;;
  esac
}

subcmd="${1:-pull}"
shift || true

case "$subcmd" in
  pull)
    provider="${1:-op}"
    pull "$provider"
    ;;
  push)
    provider="${1:-op}"
    push "$provider"
    ;;
  *)
    usage
    exit 1
    ;;
esac
