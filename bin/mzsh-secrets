#!/usr/bin/env bash
set -euo pipefail

# mzsh-secrets: fetch secrets from a password manager and write exports
# into ~/.mzsh/local.zsh under managed markers.
#
# Manifest format (JSON array):
# [
#   {"env":"GITHUB_TOKEN","provider":"op","item":"GitHub Token","field":"token"},
#   {"env":"NPM_TOKEN","provider":"bw","item":"npm token","field":"password"},
#   {"env":"AWS_PROFILE","value":"personal"},
#   {"env":"FOO","provider":"keychain","service":"foo_service","account":"$USER"}
# ]
#
# Providers:
# - op:       1Password CLI v2 (op)
# - bw:       Bitwarden CLI (bw)
# - lpass:    LastPass CLI (lpass)
# - keychain: macOS Keychain (security)
#
# Default manifest: $HOME/.mzsh/secrets.manifest.json
# Override: --manifest /path/to/file.json
# Force provider for all entries: --provider op|bw|lpass|keychain
# Dry run (show which envs would be set, without writing values): --dry-run

MANIFEST=${MZSH_SECRETS_MANIFEST:-$HOME/.mzsh/secrets.manifest.json}
SECRETS_FILE=${MZSH_SECRETS_FILE:-$HOME/.secrets.json}
FORCE_PROVIDER=""
DRY_RUN=0

usage() {
  cat >&2 << 'EOF'
Usage: mzsh secrets <subcommand> [options]

Subcommands:
  pull [--manifest PATH] [--provider PROVIDER] [--dry-run]
                            Fetch secrets from manifest and write to ~/.mzsh/local.zsh
  sample [--manifest PATH]  Create example manifest file
  install [op|bw|lpass|all] Install secrets provider CLI tools via Homebrew
  doctor                    Check setup and provide guidance

Options:
  --manifest PATH           Override default manifest path
  --provider PROVIDER       Force provider for all entries (op|bw|lpass|keychain)
  --dry-run                 Preview what would be set (values hidden)

Examples:
  mzsh secrets sample
  mzsh secrets pull
  mzsh secrets install op
  mzsh secrets doctor
EOF
}

# Parse arguments: flags come first, then subcommand, then subcommand args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --manifest)
      MANIFEST=${2:-}; shift 2 || { echo "--manifest requires a value" >&2; exit 2; } ;;
    --file)
      SECRETS_FILE=${2:-}; shift 2 || { echo "--file requires a value" >&2; exit 2; } ;;
    --provider)
      FORCE_PROVIDER=${2:-}; shift 2 || { echo "--provider requires a value" >&2; exit 2; } ;;
    --dry-run)
      DRY_RUN=1; shift ;;
    # Stop processing flags when we hit a non-flag argument (the subcommand)
    -*)
      echo "Unknown option: $1" >&2; usage; exit 2 ;;
    *) break ;;
  esac
done

# Now $1 should be the subcommand (pull, sample, install, doctor)
subcmd=${1:-pull}
[[ $# -gt 0 ]] && shift || true

# For install subcommand, capture the target (op, bw, lpass, all)
INSTALL_TARGET=${1:-}
[[ "$subcmd" == "install" ]] && [[ $# -gt 0 ]] && shift || true

LOCAL_ZSH="$HOME/.mzsh/local.zsh"
BEGIN_MARK="# mzsh-secrets BEGIN"
END_MARK="# mzsh-secrets END"

mkdir -p "$HOME/.mzsh"

require() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

provider_detect() {
  # choose best available
  if command -v op >/dev/null 2>&1; then echo op; return; fi
  if command -v bw >/dev/null 2>&1; then echo bw; return; fi
  if command -v lpass >/dev/null 2>&1; then echo lpass; return; fi
  echo keychain
}

brew_install() {
  local formula="$1" bin_name="$2"
  if ! command -v brew >/dev/null 2>&1; then
    echo "Homebrew not found. Install Homebrew from https://brew.sh or install $bin_name manually." >&2
    return 1
  fi
  if brew list --formula --versions "$formula" >/dev/null 2>&1; then
    echo "[mzsh] $formula already installed"
  else
    echo "[mzsh] Installing $formula via Homebrew"
    brew install "$formula"
  fi
}

install() {
  local target="${INSTALL_TARGET:-all}"
  case "$target" in
    op|1password|onepassword)
      brew_install 1password-cli op ;;
    bw|bitwarden)
      brew_install bitwarden-cli bw ;;
    lpass|lastpass)
      brew_install lastpass-cli lpass ;;
    all)
      brew_install 1password-cli op || true
      brew_install bitwarden-cli bw || true
      brew_install lastpass-cli lpass || true ;;
    *)
      echo "Usage: mzsh secrets install [op|bw|lpass|all]" >&2
      return 2 ;;
  esac
  echo "[mzsh] Install complete. Next: run 'mzsh secrets doctor' for setup guidance." >&2
}

doctor() {
  echo "[mzsh] Secrets environment check" >&2
  printf -- "- jq: "; if command -v jq >/dev/null 2>&1; then echo "ok ($(jq --version 2>/dev/null))"; else echo "missing -> brew install jq"; fi

  if command -v op >/dev/null 2>&1; then
    echo "- 1Password CLI (op): present ($(op --version 2>/dev/null | head -n1))"
    echo "  To sign in: op signin" 
  else
    echo "- 1Password CLI (op): missing -> mzsh secrets install op"
  fi

  if command -v bw >/dev/null 2>&1; then
    local st; st=$(bw status 2>/dev/null | jq -r '.status // "unknown"' 2>/dev/null || echo unknown)
    echo "- Bitwarden CLI (bw): present ($(bw --version 2>/dev/null)) status=$st"
    if [[ "$st" != "unlocked" ]]; then
      echo "  To unlock: BW_SESSION=\$(bw unlock --raw); export BW_SESSION"
      echo "  To login (first time): bw login"
    else
      echo "  BW_SESSION appears active."
    fi
  else
    echo "- Bitwarden CLI (bw): missing -> mzsh secrets install bw"
  fi

  if command -v lpass >/dev/null 2>&1; then
    local ls; ls=$(lpass status 2>&1 || true)
    echo "- LastPass CLI (lpass): present ($(lpass --version 2>/dev/null | head -n1))"
    echo "  Status: ${ls}" | sed 's/^/  /'
    echo "  To login: lpass login your@email"
  else
    echo "- LastPass CLI (lpass): missing -> mzsh secrets install lpass"
  fi

  echo "- macOS Keychain: available (security)"

  echo "[mzsh] Run: mzsh secrets sample   # to create a manifest"
  echo "[mzsh] Then: mzsh secrets pull    # to write exports into ~/.mzsh/local.zsh"
}

fetch_op() {
  local item="$1" field="$2"
  require op
  # op v2: use field label or exact field name
  op item get "$item" --fields "$field" --reveal 2>/dev/null || op item get "$item" --reveal | jq -r --arg f "$field" '.fields[] | select(.label==$f or .id==$f) | .value'
}

fetch_bw() {
  local item="$1" field="$2"
  require bw
  # Ensure session (non-interactive if BW_SESSION set)
  if [[ -z "${BW_SESSION:-}" ]]; then
    # Try to use an existing unlocked session if bw status shows "unlocked"
    if bw status | jq -r '.status' | grep -q unlocked; then
      :
    else
      echo "bw is locked. Run: bw unlock --raw; export BW_SESSION=..." >&2
      return 1
    fi
  fi
  local json
  json=$(bw get item "$item")
  case "$field" in
    password|pass|pw) echo "$json" | jq -r '.login.password' ;;
    username|user)    echo "$json" | jq -r '.login.username' ;;
    notes)            echo "$json" | jq -r '.notes' ;;
    *)                echo "$json" | jq -r --arg f "$field" '.fields[]? | select(.name==$f) | .value' ;;
  esac
}

fetch_lpass() {
  local item="$1" field="$2"
  require lpass
  # lpass requires prior login; assume already logged in
  case "$field" in
    password|pass|pw) lpass show --password "$item" ;;
    username|user)    lpass show --username "$item" ;;
    notes)            lpass show --notes "$item" ;;
    *)                lpass show --field="$field" "$item" ;;
  esac
}

fetch_keychain() {
  local service="$1" account="$2"
  /usr/bin/security find-generic-password -s "$service" -a "$account" -w 2>/dev/null || true
}

pull() {
  if [[ ! -f "$MANIFEST" ]]; then
    echo "Manifest not found: $MANIFEST" >&2
    echo "Run: mzsh secrets sample --manifest $MANIFEST" >&2
    exit 1
  fi
  require jq
  local tmp
  tmp=$(mktemp)
  trap 'rm -f "$tmp"' EXIT

  local had_error=0
  while IFS= read -r row; do
    local env provider item field service account value
    env=$(jq -r '.env // empty' <<<"$row")
    provider=$(jq -r '.provider // empty' <<<"$row")
    item=$(jq -r '.item // empty' <<<"$row")
    field=$(jq -r '.field // "password"' <<<"$row")
    service=$(jq -r '.service // empty' <<<"$row")
    account=$(jq -r '.account // empty' <<<"$row")
    value=$(jq -r '.value // empty' <<<"$row")

    [[ -z "$env" ]] && echo "Skipping entry without env name: $row" >&2 && continue

    # override provider via CLI if specified
    if [[ -n "$FORCE_PROVIDER" ]]; then provider="$FORCE_PROVIDER"; fi
    if [[ -z "$provider" ]]; then provider=$(provider_detect); fi

    local secret=""
    if [[ -n "$value" && "$value" != "null" ]]; then
      secret="$value"
    else
      case "$provider" in
        op)       secret=$(fetch_op "$item" "$field") ;;
        bw)       secret=$(fetch_bw "$item" "$field") ;;
        lpass)    secret=$(fetch_lpass "$item" "$field") ;;
        keychain) secret=$(fetch_keychain "${service:-$item}" "${account:-$USER}") ;;
        *)        echo "Unknown provider: $provider for $env" >&2; had_error=1; continue ;;
      esac
    fi

    if [[ -z "$secret" ]]; then
      echo "No value for $env (provider=$provider item=$item field=$field service=$service account=$account)" >&2
      had_error=1
      continue
    fi

    if (( DRY_RUN )); then
      printf 'export %s=<hidden>\n' "$env" >> "$tmp"
    else
      # Escape value safely for shell export
      printf 'export %s=%q\n' "$env" "$secret" >> "$tmp"
    fi
  done < <(jq -c '.[]' "$MANIFEST")

  # Write into local.zsh between markers
  mkdir -p "$(dirname "$LOCAL_ZSH")"
  if [[ -f "$LOCAL_ZSH" ]]; then
    # remove any previous managed block
    awk -v b="$BEGIN_MARK" -v e="$END_MARK" '
      BEGIN{skip=0}
      $0==b{skip=1; next}
      $0==e{skip=0; next}
      skip==0{print}
    ' "$LOCAL_ZSH" > "$LOCAL_ZSH.tmp"
    mv "$LOCAL_ZSH.tmp" "$LOCAL_ZSH"
  fi
  {
    echo "$BEGIN_MARK"
    cat "$tmp"
    echo "$END_MARK"
  } >> "$LOCAL_ZSH"

  if (( DRY_RUN )); then
    echo "[mzsh] Dry-run complete. Previewed exports into $LOCAL_ZSH (values hidden)." >&2
  else
    echo "[mzsh] Secrets pulled into $LOCAL_ZSH (managed block)." >&2
  fi
  echo "[mzsh] To apply in current shell: source $LOCAL_ZSH" >&2

  return $had_error
}

sample() {
  local dir
  dir=$(dirname "$MANIFEST")
  mkdir -p "$dir"
  if [[ -f "$MANIFEST" ]]; then
    echo "Manifest already exists: $MANIFEST" >&2
    return 0
  fi
  cat > "$MANIFEST" <<'JSON'
[
  { "env": "GITHUB_TOKEN", "provider": "op", "item": "GitHub Token", "field": "token" },
  { "env": "NPM_TOKEN",    "provider": "bw", "item": "npm token",    "field": "password" },
  { "env": "FOO_API_KEY",  "provider": "keychain", "service": "foo_api_key", "account": "$USER" },
  { "env": "AWS_PROFILE",  "value": "personal" }
]
JSON
  echo "Wrote example manifest to $MANIFEST" >&2
}

push() {
  local secrets_file="${SECRETS_FILE}"
  if [[ ! -f "$secrets_file" ]]; then
    echo "Secrets file not found: $secrets_file" >&2
    echo "" >&2
    echo "Create ~/.secrets.json with entries like:" >&2
    echo "[" >&2
    echo "  { \"env\": \"MY_TOKEN\", \"value\": \"token-value-here\" }," >&2
    echo "  { \"env\": \"ANOTHER_TOKEN\", \"value\": \"another-value\" }" >&2
    echo "]" >&2
    return 1
  fi

  require jq
  require op

  echo "[mzsh] Pushing secrets from $secrets_file to 1Password..." >&2

  local count=0
  while IFS= read -r row; do
    local env value item_name
    env=$(jq -r '.env // empty' <<<"$row")
    value=$(jq -r '.value // empty' <<<"$row")
    item_name="${env} (mzsh)"

    [[ -z "$env" || -z "$value" ]] && continue

    # Check if item already exists
    if op item list --format=json 2>/dev/null | jq -e --arg name "$item_name" '.[] | select(.title == $name)' >/dev/null 2>&1; then
      # Update existing item
      op item edit "$item_name" password="$value" 2>/dev/null || true
      echo "[mzsh] Updated: $env" >&2
    else
      # Create new item
      op item create --category login --title "$item_name" password="$value" 2>/dev/null || true
      echo "[mzsh] Created: $env" >&2
    fi
    ((count++))
  done < <(jq -c '.[]' "$secrets_file")

  echo "[mzsh] Pushed $count secret(s) to 1Password" >&2
}

case "$subcmd" in
  pull)    pull ;;
  push)    push ;;
  sample)  sample ;;
  install) install ;;
  doctor)  doctor ;;
  *) usage; exit 1 ;;
esac
