#!/usr/bin/env bash
set -euo pipefail

# mzsh-secrets: fetch secrets from a password manager and write exports
# into ~/.mzsh/local.zsh under managed markers.
#
# Manifest format (JSON array):
# [
#   {"env":"GITHUB_TOKEN","provider":"op","item":"GitHub Token","field":"token"},
#   {"env":"NPM_TOKEN","provider":"bw","item":"npm token","field":"password"},
#   {"env":"AWS_PROFILE","value":"personal"},
#   {"env":"FOO","provider":"keychain","service":"foo_service","account":"$USER"}
# ]
#
# Providers:
# - op:       1Password CLI v2 (op)
# - bw:       Bitwarden CLI (bw)
# - lpass:    LastPass CLI (lpass)
# - keychain: macOS Keychain (security)
#
# Default manifest: $HOME/.mzsh/secrets.manifest.json
# Override: --manifest /path/to/file.json
# Force provider for all entries: --provider op|bw|lpass|keychain
# Dry run (show which envs would be set, without writing values): --dry-run

MANIFEST=${MZSH_SECRETS_MANIFEST:-$HOME/.mzsh/secrets.manifest.json}
FORCE_PROVIDER=""
DRY_RUN=0

usage() {
  sed -n '1,80p' "$0" | sed -n '1,40p' >&2
  echo >&2 "\nUsage: mzsh secrets <pull|sample> [options]"
}

cmd=${1:-}
shift || true

while [[ $# -gt 0 ]]; do
  case "$1" in
    --manifest)
      MANIFEST=${2:-}; shift 2 || { echo "--manifest requires a value" >&2; exit 2; } ;;
    --provider)
      FORCE_PROVIDER=${2:-}; shift 2 || { echo "--provider requires a value" >&2; exit 2; } ;;
    --dry-run)
      DRY_RUN=1; shift ;;
    pull|sample)
      set -- "$1" "$@"; break ;;
    *) break ;;
  esac
done

subcmd=${1:-pull}
shift || true

LOCAL_ZSH="$HOME/.mzsh/local.zsh"
BEGIN_MARK="# mzsh-secrets BEGIN"
END_MARK="# mzsh-secrets END"

mkdir -p "$HOME/.mzsh"

require() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

provider_detect() {
  # choose best available
  if command -v op >/dev/null 2>&1; then echo op; return; fi
  if command -v bw >/dev/null 2>&1; then echo bw; return; fi
  if command -v lpass >/dev/null 2>&1; then echo lpass; return; fi
  echo keychain
}

fetch_op() {
  local item="$1" field="$2"
  require op
  # op v2: use field label or exact field name
  op item get "$item" --fields "$field" --reveal 2>/dev/null || op item get "$item" --reveal | jq -r --arg f "$field" '.fields[] | select(.label==$f or .id==$f) | .value'
}

fetch_bw() {
  local item="$1" field="$2"
  require bw
  # Ensure session (non-interactive if BW_SESSION set)
  if [[ -z "${BW_SESSION:-}" ]]; then
    # Try to use an existing unlocked session if bw status shows "unlocked"
    if bw status | jq -r '.status' | grep -q unlocked; then
      :
    else
      echo "bw is locked. Run: bw unlock --raw; export BW_SESSION=..." >&2
      return 1
    fi
  fi
  local json
  json=$(bw get item "$item")
  case "$field" in
    password|pass|pw) echo "$json" | jq -r '.login.password' ;;
    username|user)    echo "$json" | jq -r '.login.username' ;;
    notes)            echo "$json" | jq -r '.notes' ;;
    *)                echo "$json" | jq -r --arg f "$field" '.fields[]? | select(.name==$f) | .value' ;;
  esac
}

fetch_lpass() {
  local item="$1" field="$2"
  require lpass
  # lpass requires prior login; assume already logged in
  case "$field" in
    password|pass|pw) lpass show --password "$item" ;;
    username|user)    lpass show --username "$item" ;;
    notes)            lpass show --notes "$item" ;;
    *)                lpass show --field="$field" "$item" ;;
  esac
}

fetch_keychain() {
  local service="$1" account="$2"
  /usr/bin/security find-generic-password -s "$service" -a "$account" -w 2>/dev/null || true
}

pull() {
  if [[ ! -f "$MANIFEST" ]]; then
    echo "Manifest not found: $MANIFEST" >&2
    echo "Run: mzsh secrets sample --manifest $MANIFEST" >&2
    exit 1
  fi
  require jq
  local tmp
  tmp=$(mktemp)
  trap 'rm -f "$tmp"' EXIT

  local had_error=0
  while IFS= read -r row; do
    local env provider item field service account value
    env=$(jq -r '.env // empty' <<<"$row")
    provider=$(jq -r '.provider // empty' <<<"$row")
    item=$(jq -r '.item // empty' <<<"$row")
    field=$(jq -r '.field // "password"' <<<"$row")
    service=$(jq -r '.service // empty' <<<"$row")
    account=$(jq -r '.account // empty' <<<"$row")
    value=$(jq -r '.value // empty' <<<"$row")

    [[ -z "$env" ]] && echo "Skipping entry without env name: $row" >&2 && continue

    # override provider via CLI if specified
    if [[ -n "$FORCE_PROVIDER" ]]; then provider="$FORCE_PROVIDER"; fi
    if [[ -z "$provider" ]]; then provider=$(provider_detect); fi

    local secret=""
    if [[ -n "$value" && "$value" != "null" ]]; then
      secret="$value"
    else
      case "$provider" in
        op)       secret=$(fetch_op "$item" "$field") ;;
        bw)       secret=$(fetch_bw "$item" "$field") ;;
        lpass)    secret=$(fetch_lpass "$item" "$field") ;;
        keychain) secret=$(fetch_keychain "${service:-$item}" "${account:-$USER}") ;;
        *)        echo "Unknown provider: $provider for $env" >&2; had_error=1; continue ;;
      esac
    fi

    if [[ -z "$secret" ]]; then
      echo "No value for $env (provider=$provider item=$item field=$field service=$service account=$account)" >&2
      had_error=1
      continue
    fi

    if (( DRY_RUN )); then
      printf 'export %s=<hidden>\n' "$env" >> "$tmp"
    else
      # Escape value safely for shell export
      printf 'export %s=%q\n' "$env" "$secret" >> "$tmp"
    fi
  done < <(jq -c '.[]' "$MANIFEST")

  # Write into local.zsh between markers
  mkdir -p "$(dirname "$LOCAL_ZSH")"
  if [[ -f "$LOCAL_ZSH" ]]; then
    # remove any previous managed block
    awk -v b="$BEGIN_MARK" -v e="$END_MARK" '
      BEGIN{skip=0}
      $0==b{skip=1; next}
      $0==e{skip=0; next}
      skip==0{print}
    ' "$LOCAL_ZSH" > "$LOCAL_ZSH.tmp"
    mv "$LOCAL_ZSH.tmp" "$LOCAL_ZSH"
  fi
  {
    echo "$BEGIN_MARK"
    cat "$tmp"
    echo "$END_MARK"
  } >> "$LOCAL_ZSH"

  if (( DRY_RUN )); then
    echo "[mzsh] Dry-run complete. Previewed exports into $LOCAL_ZSH (values hidden)." >&2
  else
    echo "[mzsh] Secrets pulled into $LOCAL_ZSH (managed block)." >&2
  fi

  return $had_error
}

sample() {
  local dir
  dir=$(dirname "$MANIFEST")
  mkdir -p "$dir"
  if [[ -f "$MANIFEST" ]]; then
    echo "Manifest already exists: $MANIFEST" >&2
    return 0
  fi
  cat > "$MANIFEST" <<'JSON'
[
  { "env": "GITHUB_TOKEN", "provider": "op", "item": "GitHub Token", "field": "token" },
  { "env": "NPM_TOKEN",    "provider": "bw", "item": "npm token",    "field": "password" },
  { "env": "FOO_API_KEY",  "provider": "keychain", "service": "foo_api_key", "account": "$USER" },
  { "env": "AWS_PROFILE",  "value": "personal" }
]
JSON
  echo "Wrote example manifest to $MANIFEST" >&2
}

case "$subcmd" in
  pull)   pull ;;
  sample) sample ;;
  *) usage; exit 1 ;;
esac
